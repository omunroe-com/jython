/*
 * Gradle build for Jython. See also settings.gradle.
 *
 * This is an attempt to build a distributable JAR using Gradle that could be
 * cited as a dependency by other Gradle or Maven projects, when they use the
 * Jython interpreter from Java (under JSR-223 or directly).
 *
 * At present, the build is additional to the Ant build that remains the
 * primary and reliable support for development, for test, and to build the
 * Jython installers.
 *
 * The delivered jar should contain only Jython project material (Java classes
 * and the Python library) while the many JARs Jython depends on will be cited
 * in the accompanying metadata as dependencies.
 *
 * The Jython source structure does not follow the standard convention for
 * Gradle. This script deals with that without changing it, but it uses a build
 * directory (build2) entirely separate from Ant's, in which generated and
 * compiled material is posted conformant with Gradle conventions. This means
 * that the later tasks Gradle provides (test and jar) do not need so much
 * customisation.
 */

plugins {
    id 'java-library'
    id 'antlr'
    id 'maven-publish'
}

import java.text.SimpleDateFormat

// ---------------- Determine the version of Jython ----------------------------

/*
 * This one string will be used to name the generated JAR and version-stamp the
 * application. It should be all you have to edit to version a release built
 * here. But of course you have to do it the hard way too (see build.xml) as
 * long as Ant is also used.
 */
// <major> . <minor> ( . <micro> )? ( <release> <serial> )? ([-+] <word>? )?

version = '2.7.2a1+'

// Valid examples (please preserve in comments):
//version = '2.7.2a2'
//version = '2.7.2b1-SNAPSHOT'
//version = '2.7.2b1'
//version = '2.7.2rc1'
//version = '2.7.2'

group = 'org.python'


// ---------------- Miscellaneous configuration --------------------------------

// Support Java 7 onwards
sourceCompatibility = '1.7'
targetCompatibility = '1.7'

project.compileJava.options.debug = true


// Separate the Gradle build from that of Ant
buildDir = file('build2')
ext {
    buildDate = new Date()
    /*
     * The directory structure supporting the build has separate locations for
     * several intermediate stages.
     */
    // Java source generated by ANTLR
    antlrGenDir = "$buildDir/gensrc/org/python/antlr"
    // Intermediate locations for compiled classes
    unexposedDir = "$buildDir/unexposed"
    exposedDir = "$buildDir/exposed"
    // The standard library may safely be assembled in-place as a resource
    pythonLibDir = "$buildDir/python/Lib/"
    buildLibDir = "$buildDir/resources/main/Lib/"
    buildTestLibDir = "$buildDir/resources/test/Lib/"
    compiledLibDir = "$buildDir/resources/main/Lib/"
    compiledTestLibDir = "$buildDir/resources/test/Lib/"
}


repositories {
    /*
     * Jython is distributed through Maven Central. Get our dependencies there
     * too.
     */
    mavenCentral()
}

sourceSets {

    main {  // Non-standard locations must be specified explicitly

        antlr {
            srcDirs = ['grammar']
            exclude 'Base.g' // Not used (and produces errors)
        }

        java {
            srcDirs = ['src', project.ext.antlrGenDir]
            exclude 'com/**'    // for now
        }

        resources {
            // Resources in project root, but this invites an explosion.
            // ... so claim no sources:
            srcDirs = []
            // and fix it in task processResources
        }
    }

    test {  // Non-standard locations must be specified explicitly

        java {
            srcDirs = ['tests/java']
            exclude 'com/**'    // XXX for now
        }
    }
}

dependencies {
    /*
     * These must correspond fairly exactly with the external libraries (JARs)
     * mentioned in the Ant build.xml.
     */

    // Using a version available from repo (not 'extlibs/servlet-api-2.5' as in build.xml)
    implementation group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0'

    // implementation 'mysql-connector-java-5.1.42-bin'
    // implementation 'postgresql-42.1.1.jre7'

    // pin to Antlr 3.1.3 until we upgrade parsing
    antlr 'org.antlr:antlr:3.1.3' // use ANTLR version 3
    implementation 'org.antlr:antlr-runtime:3.1.3'
    implementation 'org.antlr:stringtemplate:3.2.1'

    implementation group: 'org.apache.commons', name: 'commons-compress', version: '1.14'

    // pin to ASM 5.2 until we upgrade compilation
    implementation group: 'org.ow2.asm', name: 'asm', version: '5.2'
    implementation group: 'org.ow2.asm', name: 'asm-commons', version: '5.2'
    implementation group: 'org.ow2.asm', name: 'asm-util', version: '5.2'

    api group: 'com.google.guava', name: 'guava', version: '22.0-android'
    implementation group: 'com.ibm.icu', name: 'icu4j', version: '59.1'

    implementation group: 'com.carrotsearch', name: 'java-sizeof', version: '0.0.5'

    implementation group: 'com.github.jnr', name: 'jffi', version: '1.2.16'
    implementation group: 'com.github.jnr', name: 'jnr-netdb', version: '1.1.6'
    implementation group: 'com.github.jnr', name: 'jnr-ffi', version: '2.1.7'
    implementation group: 'com.github.jnr', name: 'jnr-posix', version: '3.0.44'
    implementation group: 'com.github.jnr', name: 'jnr-constants', version: '0.9.9'

    implementation group: 'jline', name: 'jline', version: '2.14.5'

    implementation group: 'io.netty', name: 'netty-buffer', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-codec', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-common', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-handler', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-resolver', version: '4.1.24.Final'
    implementation group: 'io.netty', name: 'netty-transport', version: '4.1.24.Final'

    // Used implicitly in the Ant build, must be explicit here
    implementation group: 'org.apache.ant', name: 'ant', version: '1.9.7'

    testImplementation group: 'junit', name: 'junit', version: '4.10'

}

// ---------------- Resource Processing ----------------------------------------

/*
 * Jython brings several files we could treat as resources, but they do not sit
 * in the Gradle-conventional 'main/resources' directory, rather are in the
 * project root or rub shoulders with the java source. Pick them individually.
 *
 * Several tasks defined below declare that processResources depends on them,
 * with the objective that at the end of processResources all generated
 * resources and the stdlib (but not the compiled stdlib) should be in place
 * in $buildDir/resources/main.
 */
processResources {
    from(file('.')) {
        include 'LICENSE.txt'
    }
    from(file('src')) {
        include 'META-INF/**'
        include 'org/python/modules/ucnhash.dat'
    }
}

// ---------------- ANTLR Task -------------------------------------------------

generateGrammarSource {
    maxHeapSize = "512m"
    outputDirectory = file(antlrGenDir)
}

// ---------------- compleJava Task --------------------------------------------

compileJava {
    // Divert compiled classes to intermediate location pre-exposure.
    destinationDir = file(unexposedDir)
}

// ---------------- Expose Task ------------------------------------------------

/*
 * The exposer operates between the output of compileJava (unexposed directory)
 * and a second intermediate location (exposed directory). These two the
 * mergeExposed task will finally combine in the Gradle-standard classes
 * directory used as input by the jar task.
 */
configurations {
    expose.extendsFrom(implementation)
}

dependencies {
    // The expose (Ant) task depends on classes compiled to here:
    expose files(unexposedDir)
}

// A (Gradle) task to run the Ant task 'expose'.
task expose (group: 'Custom', dependsOn: compileJava) {

    description = 'Expose Java types to Python using their annotations.'

    // Allow Gradle to infer the need to regenreate the outputs
    inputs.files(fileTree("${project.ext.unexposedDir}/org/python"))
    outputs.dir(project.ext.exposedDir)

    doLast {
        /*
         * Define an Ant task called 'expose' in the project's AntBuilder.
         * We can't define it until ExposeTask has been compiled.
         */
        ant.taskdef(
            name: 'expose',
            classname: 'org.python.expose.generate.ExposeTask',
            classpath: configurations.expose.asPath
         )

        // Use the Gradle-conventional directory structure (not the legacy one).
        ant.expose(
            srcdir: file(project.ext.unexposedDir),
            destdir: mkdir(file(project.ext.exposedDir)),
            includesfile: file('CoreExposed.includes')
        )
    }
}

// Task to merge the exposed and unexposed classes
task mergeExposed(group: 'Custom', type:Copy, dependsOn: expose) {
    description = 'Copy exposed Java types to classes.'
    // Exposed version will take precedence
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from file(exposedDir)
    from file(unexposedDir)
    into sourceSets.main.output.classesDirs.singleFile
}

// Attach to the classes task the placing of all compiled and exposed classes.
classes.dependsOn(mergeExposed)


// ---------------- Version-related file generation ----------------------------

/*
 * Write the information that org.python.Version reads from
 * org/python/version.properties in the class file structure. The inputs to
 * this are: information from Mercurial (hg command required); project.version;
 * and project.ext.buildDate. The task works quite hard to decode
 * project.version, which must have the correct form, to deduce whether you
 * really intend this to be a release. If anything comes after the release
 * number, typically it's a '+' sign, the version becomes a snapshot.
 */
task generateVersionInfo(
        type: WriteProperties,
        description: 'Write the version information as properties') {

    outputFile = file("${processResources.destinationDir}/org/python/version.properties")
    comment = ' Jython version information (from build.gradle)'

    // Create the properties when the task runs. But do it before the write!
    doFirst {
        /*
         * Query Mercurial for version and tagging.
         */
        String hgOutput = 'hg identify -ibt'.execute().text
        hgOutput = hgOutput.split('\n', 2)[0]

        // <revision-id>(+)? <branch> <tag>
        String[] parts = hgOutput.split(/\s+/, 3)
        if (parts.length != 3) {
            throw new IllegalArgumentException(
                    "Cannot split Mercurial output '$hgOutput' into 3")
        }
        def (ident, branch, tag) = parts
        property('jython.build.hg_branch', branch)
        property('jython.build.hg_tag', tag)
        property('jython.build.hg_version', ident)

        /*
         * Decompose the version string into elements for Jython to access as
         * properties. (The Ant build.xml requires them to be set in parts, but
         * we can work it out from the .)
         */
        // <major>.<minor>(.<micro>)(<release><serial>)?([-+]<snapshot>)?
        def versionRegex = /(\d+)\.(\d+)(\.(\d+))?((a|b|rc)(\d+))?([-+]\w*)?/
        def versionMatcher = project.version =~ versionRegex
        if (versionMatcher.count != 1) {
            throw new IllegalArgumentException(
                    "Cannot parse project version string '${project.version}'")
        }
        // In principle it could match more than once: take the leftmost
        def versionResult = versionMatcher[0]

        // <major>.<minor> means <major>.<minor>.0
        String major = versionResult[1]
        String minor = versionResult[2]
        String micro = versionResult[3] ? versionResult[4] : '0'

        // Convert the optional <release><serial> to numbers
        int SNAPSHOT = 0xaa
        int level = 0, serial = 0
        if (versionResult[5]) {
            // This is some kind of pre-final release (unless snapshaot)
            serial = versionResult[7] as int
            switch (versionResult[6]) {
                case 'a': level = 0xa; break // ALPHA release
                case 'b': level = 0xb; break // BETA release
                case 'rc': level = 0xc; break // release candidate
            }
        } else {
            // Not marked as a/b/rc so ostensibly a final release.
            level = 0xf
        }

        // Except, if there was something after the version we decoded ...
        if (versionResult[8]) {
            level = SNAPSHOT // it's snapshot or dev version of some kind
            serial = 0
        }

        property('jython.version', project.version)
        property('jython.major_version', major)
        property('jython.minor_version', minor)
        property('jython.micro_version', micro)
        property('jython.release_level', level)
        property('jython.release_serial', serial)

        /*
         * Time-stamp the build. In the time part, the ':' gets escaped to
         * '\:', consistent with Properties.store(), unlike the Ant build.
         */
        property('jython.build.time',
                (new SimpleDateFormat('HH:mm:ss'))
                .format(project.ext.buildDate))
        property('jython.build.date',
                (new SimpleDateFormat('MMM d yyyy'))
                .format(project.ext.buildDate))

        /*
         * Remind the developer about tagging it if it looks like a release,
         * or to adjust project.version if we're moving on from the release.
         */
        if (level != SNAPSHOT) {
            def L = [0:'', 10:'a', 11:'b', 12:'rc', 15:'']
            String release = "$major.$minor.$micro${L[level]}${serial?:''}"
            println "This build is versioned for distribution as $release"
            if (tag == 'tip' || ident.endsWith('+')) {
                println "If this really is distributable, " +
                        "don't forget to tag it in the repository.\n" +
                        "Alternatively, add a suffix to version = " +
                        "'${project.version}' in build.gradle to shut this up."
            }
        }
    }
}

// Attach this task to processResources
processResources.dependsOn(generateVersionInfo)


// ---------------- Copy Python Library ----------------------------------------

/*
 * The default behaviour of the Java plug-in is to make a JAR of the classes in
 * the "main" source set. We need a more complex assembly that provides users
 * with exposed classes instead of their plain counterparts, and also various
 * configuration files and the Python library.
 *
 * These copies include the tests, so we can test things :), but a subsequent
 * JarTask of the build should exclude them as necessary. (Not yet implemented.)
 */

ext {
    libPython = 'lib-python/2.7'
    libJython = 'Lib'
    libTestSpecs = [
        'distutils/tests/',
        'email/test/',
        'json/tests/',
        'lib2to3/tests/',
        'unittest/test/',
        'test/'
    ]
}

/*
 * Copy the Python standard library. We take this from a distribution of
 * CPython, but take only the files specified in CPythonLib.includes.
 * The Jython version of the standard library will be copied to the same place.
 * Files from the Jython library having the same name (relative path) as one
 * in CPythonLib.includes thereby take precedence.
 */
task mergePythonLib(
        type: Copy,
        description: 'Merge lib-python and Jython Lib') {

    // There might be a way using a collection of File rather than actual copy.
    into pythonLibDir

    // Copy Jython Lib, with precedence over CPython files of the same name
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
    from libJython
    exclude '**/*.class'

    // Allow Gradle to infer the need to regenerate the outputs
    inputs.dir libJython
    inputs.dir libPython
    inputs.file file('CPythonLib.includes')

    doFirst {
        // Select the CPython stdlib files by making a list.
        def cPythonLibIncludes = []
        // Read list from CPythonLib.includes, stripping comments and spaces.
        file('CPythonLib.includes').eachLine { line ->
            def trimmed = line.split('#', 2)[0].trim()
            if (trimmed.length() > 0) {
                cPythonLibIncludes << trimmed
            }
        }
        // Copy the subset as specified by the list
        project.copy {
            into pythonLibDir
            duplicatesStrategy = DuplicatesStrategy.EXCLUDE
            from libPython
            include cPythonLibIncludes
            exclude '**/*.pyc', '**/*.pyd'
        }
    }
}

/*
 * Copy from the merge location into the main resources, excluding material
 * only needed for tests.
 */
task copyLib(
        type: Copy,
        dependsOn: mergePythonLib,
        description: 'Copy merged Python library (main excluding tests)') {
    into buildLibDir
    from pythonLibDir
    exclude '**/*.pyc', '**/*.pyd', '**/*.class'
    // Exclude tests and test material
    exclude libTestSpecs
}

// Attach this task to processResources
processResources.dependsOn(copyLib)

/*
 * Copy from the merge location into the test resopurces, including only
 * that extra material needed for tests.
 */
task copyTestLib(
        type: Copy,
        dependsOn: mergePythonLib,
        description: 'Copy merged Python library (tests only)') {
    into buildTestLibDir
    from pythonLibDir
    exclude '**/*.pyd', '**/*.class' // test material includes .pyc files
    // Include only tests and test material
    include libTestSpecs
}

// Attach this task to processResources
processTestResources.dependsOn(copyTestLib)


// ---------------- Jython-Compile Python --------------------------------------

/*
 * Compile the Python modules to .class files for the JAR. Whereas Jython runs
 * happily with a concrete Lib folder, creating and caching the .class files,
 * when Jython is supplied as a JAR, we prefer to compile the class files once
 * in advance.
 */

configurations {
    pycompile.extendsFrom(implementation)
}

dependencies {
    // Jython as built so far should be on the path of the jycompile (Ant) task
    pycompile files("$buildDir/classes/java/main")
    pycompile files("$buildDir/resources/main")
}

// A (Gradle) task to run the Ant task 'jycompile' (not pycompile).
task pycompile(
        group: 'Custom',
        description: 'Compile the Python modules to .class files for the JAR') {

    // Compiler depends on rest of Jython being fully assembled in 'classes'
    dependsOn classes
    // Note that classes depends on processResources (Java plug-in).

    // Allow Gradle to infer the need to regenerate the outputs
    inputs.dir project.ext.buildLibDir
    outputs.dir project.ext.compiledLibDir

    doFirst {
        /*
         * Define an Ant task called 'jycompile' in the project's AntBuilder.
         * We can't define it until JythoncAntTask has been compiled, so this
         * must happen during the execution of the task (early).
         */
         ant.taskdef(
            name: 'jycompile',
            classname: 'org.python.util.JycompileAntTask',
            classpath: configurations.pycompile.asPath
         )
    }

    doLast {
        /*
         * Now use the 'jycompile' Ant task tocompile the Python source we
         * supply to users. The exclusions are copied from build.xml, as also
         * is this comment:
            <!-- One might think that the exclusion of lib2to3/tests/** is
                 recursive, but one would be wrong ;) It's actually only
                 two levels, so for now the workaround is to also include
                 data/myfixes/**

                 This exclusion for lib2to3/tests/ in general is necessary
                 because data/infinite_recursion.py is not compileable by
                 Jython - it's too large and will exceed Java method
                 limits for the top level script; nor is
                 data/py3_test_grammar.py - it's Python 3. Meanwhile
                 refactor.get_all_fix_names depends on having *.py, not
                 exclusively $py.class, files available in
                 lib2to3/tests/data/myfixes/**. -->
         */
        def exclusions = ['test/**', 'lib2to3/tests/**',
            'lib2to3/tests/data/myfixes/**']
        ant.jycompile(
            srcdir: project.ext.buildLibDir,
            destdir: project.ext.compiledLibDir,
            excludes: exclusions.join(',')    // Yes, it's that way round :o
        )
    }
}


// ---------------- Building the JARs ------------------------------------------

/*
 * The default behaviour of the Java plug-in is to make a JAR of the classes in
 * the "main" source set and its resources. Having carefully substituted/added
 * exposed classes in the assembled classes directory, and having prepared the
 * (compiled) stdlib as a resource, this is close to what we need, with a few
 * adjustments as noted.
 */
jar {

    // Ensure that compiled stdlib is part of the resources to JAR.
    dependsOn pycompile

    // It is important for import that X$py.class be newer than X.py
    preserveFileTimestamps = true

    // We don't JAR the expose tool itself
    exclude 'org/python/expose/generate/**'

    // Build a custom manifest
    manifest {
        // These attribute values are based on inspecting the ant build
        attributes ([
            'Main-Class': 'org.python.util.jython',
            'Built-By': 'build.gradle',
        ])

        attributes( [ // Build-Info section
            'version': project.version,
            'build-compiler': 'modern',
            'jdk-target-version': project.targetCompatibility,
            'debug': compileJava.options.debug
        ], 'Build-Info' )
    }
}

/*
 * This is a task complementary to the jar task, taking just the test material.
 * This is not published via the main repositories because it counts as a
 * distinct needs a distinct artefact with its own POM.
 */
task testJar(type: Jar) {
    classifier = 'tests'
    
    from sourceSets.test.output
    // We don't JAR the expose tool, so we don't JAR the tests
    exclude 'org/python/expose/generate/**'

    // Build a custom manifest
    manifest {
        // These attribute values are based on inspecting the ant build
        attributes ([
            //'Main-Class': 'org.python.util.jython',
            'Built-By': 'build.gradle',
        ])

        attributes( [ // Build-Info section
            'version': project.version,
            'build-compiler': 'modern',
            'jdk-target-version': project.targetCompatibility,
            'debug': compileTestJava.options.debug
        ], 'Build-Info' )
    }
}


// ---------------- Documentation ----------------------------------------------

/*
 * JavaDoc, anyway.
 */

javadoc {
    options.encoding = 'UTF-8'
}

// ---------------- Publication ------------------------------------------------

/*
 * Post the JAR we built to a public repository. We provide secondary -source
 * and -javadoc JARs too (supporting 'main').
 *
 * How do we test the artifact actually published is correct? The 'test' task
 * tests Jython laid out in the build directory, not the JAR we propose to
 * distribute.
 *
 * Maybe have a second JAR that contains the additional material necessary to
 * run integration tests (regression tests and others). Python tests are
 * (incorrectly) in the main JAR at present.
 */

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allJava
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

publishing {

    publications {
        // The production JAR we expect to be cited as a dependency by users
        main(MavenPublication) {

            from components.java
            
            // Also provide the source.
            artifact sourcesJar
            // Also provide the docs. (Some javadoc errors currently.)
            //artifact javadocJar
        }
    }

    repositories {
        // Dummy one for test: need sonatype here and credentials from user
        maven {
            name = 'myRepo'
            url = "file://${buildDir}/repo"
        }
    }
}


// ---------------- Java unit tests --------------------------------------------

ext {
    //distDir = relativePath("$buildDir/assembly")
    testSourceDir = relativePath('tests/java')
}


dependencies {
    // Put the exposed classes on the path of the test tasks
    testImplementation files(expose)
}

// Ensure exposed classes are ahead of standard path
sourceSets.test {
    compileClasspath  = files(expose.outputs) + compileClasspath
    runtimeClasspath = files(expose.outputs) + runtimeClasspath
    // println "runtimeClasspath = ${runtimeClasspath.asPath}"
}

compileTestJava {
    dependsOn expose
    options.debug = project.compileJava.options.debug
}

test {

    dependsOn copyLib

    // Stop on first test failure
    failFast = true

    // Properties as defined in Ant target javatest-basepath
    // XXX Not sure of all that python.home is used for in tests.
    systemProperty 'python.home', file(copyLib.destinationDir).parent
    systemProperty 'python.test.source.dir', project.ext.testSourceDir
    // Place cache outside the targets for jar task
    systemProperty 'python.cachedir', "${project.buildDir}/cachedir"

    // Include/exclude based on Ant target javatest-basepath
    include '**/*Test*'
    exclude '**/InterpTestCase'
    exclude '**/jythonTest*'            // Must run interactively
    exclude 'org/python/antlr/**'
    exclude 'org/python/tests/imp/**'   // See build.xml:importest

    // Some additional exclusions or else the task fails

    // FIXME: leaves stdin/out/err as PyFileWriter that has no fileno()
    // causing _ioTest to fail.
    exclude '**/jsr223/*'

    // FIXME: Tests that hard-code directory paths (use a symbol):
    exclude 'org/python/compiler/custom_proxymaker/**'
    exclude 'org/python/compiler/JavaMakerSmokeTest.class'

    // FIXME: Failing test finds project root from test class location
    exclude 'org/python/core/PySystemState_registry_Test.class'

    // FIXME: Fails as sys._jy_console not set when run under Gradle
    exclude 'org/python/util/InterpreterTest.class'

    doFirst {
        println "systemProperties = $systemProperties"
    }

    /* From build.xml :

    <target name="javatest-basepath" depends="developer-build">
        <mkdir dir="${junit.reports}"/>
        <junit fork="true" printsummary="true">
            <formatter type="xml"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <sysproperty key="python.test.source.dir" value="${test.source.dir}"/>
            <classpath refid="test.classpath"/>
            <batchtest todir="${junit.reports}" skipNonTests="true">
                <fileset dir="${test.source.dir}" includes="** /*Test*.java">
                    <exclude name="** /InterpTestCase.java" />
                    <exclude name="** /jythonTest*" /> <!-- Must run interactively -->
                    <exclude name="org/python/antlr/**" />
                    <exclude name="org/python/tests/imp/**" /> <!-- See importest -->
                    <exclude name=".classpath" />
                    <exclude name=".project" />
                </fileset>
            </batchtest>
        </junit>
    </target>

    <target name="importest" depends="developer-build" description="run all the JUnit tests that need tests/python in the path.">
        <mkdir dir="${junit.reports}"/>
        <junit fork="true" printsummary="true">
            <formatter type="xml"/>
            <sysproperty key="python.home" value="${dist.dir}"/>
            <sysproperty key="python.test.source.dir" value="${test.source.dir}"/>
            <classpath refid="test.classpath"/>
            <classpath refid="test.classpath"/>
            <classpath>
                <pathelement location="${jython.base.dir}/tests/python"/>
            </classpath>
            <batchtest todir="${junit.reports}">
                <fileset dir="${test.source.dir}" includes="org/python/tests/imp/*Test*.java">
                </fileset>
            </batchtest>
        </junit>
    </target>

    */
}


// ---------------- Miscellaneous fettling of the prepare phase ----------------

// Source is globally UTF-8 (well, nearly).
tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
}



// ---------------- Tasks for debugging ----------------------------------------


task dumpCP {
    doLast {
        //println('configurations.testCompile:')
        //configurations.testCompile.each { println it }
        //println('configurations.testRuntime:')
        //configurations.testRuntime.each { println it }
        println('configurations.expose:')
        configurations.expose.each { println it }
        println('configurations.pycompile:')
        configurations.pycompile.each { println it }
    }
}

task dumpSS {
    doLast {
        println '*** source sets ***'
        for (ss in sourceSets) {
            String name = ss.name
            println ss
            println "  ${name}.compileConfigurationName = ${ss.compileConfigurationName}"
            println "  ${name}.implementationConfigurationName = ${ss.implementationConfigurationName}"
            println "  ${name}.runtimeConfigurationName = ${ss.runtimeConfigurationName}"
            println "  ${name}.java.srcDirs = ${ss.java.srcDirs}"
            println "  ${name}.antlr.srcDirs = ${ss.antlr.srcDirs}"
            println "  ${name}.resources.srcDirs = ${ss.resources.srcDirs}"
            println "  ${name}.output.dirs = ${ss.output.dirs.files}"
            println "  ${name}.output.classesDirs = ${ss.output.classesDirs.files}"
            println "  ${name}.output.resourcesDir = ${ss.output.resourcesDir}"
            println "  ${name}.classesTaskName = ${ss.classesTaskName}"
            println "  ${name}.compileJavaTaskName = ${ss.compileJavaTaskName}"
            println "  ${name}.jarTaskName = ${ss.jarTaskName}"
        }
    }
}
